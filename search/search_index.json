{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Temperature Server","text":""},{"location":"#overview","title":"Overview","text":"<p>This Server receives measurements from a cooking thermometer with two probes. One measures the temperature of the oven and the other one the core temperature of the meat. The measurements are shown on a webpage and the remaining time is predicted until the core reaches a specified temperature.</p>"},{"location":"#data-flow","title":"Data Flow","text":"<pre><code>flowchart LR\nmeas[Measurement Device]\nsim[Simulator]\ninputs[Inputs]\ndatabase[(Database)]\nserver[Server]\npredictor[Predictor]\nJavaScriptApi[JavaScriptApi]\ngui[Web Client]\n\nmeas --&gt; inputs\nsim --&gt; inputs\ninputs --&gt; server\ndatabase &lt;--&gt; server\nserver &lt;--&gt; predictor\nserver &lt;--&gt; JavaScriptApi\nJavaScriptApi &lt;--&gt; gui</code></pre>"},{"location":"#inputs","title":"Inputs","text":"<p>This section explains how measurement data can be sent to the server.</p>"},{"location":"#http-post","title":"HTTP-POST","text":"<p>Measurements can be sent via a HTTP/POST message. The messages needs to have the following format.</p> <pre><code>Measurement,device=TempSens,Sensor=&lt;name&gt; value=&lt;val&gt; &lt;ts&gt;\n</code></pre> <p>where:</p> <pre><code>&lt;name&gt; is the number of the sensor (1 or 2).\n&lt;val&gt; is the measured value as float.\n&lt;ts&gt; is the timestamp in ns since epoch.\n</code></pre> <p>The timestamp is optional. If no timestamp is given the time at which the message arrives is used. After each Measurement a newline indicates a new Measurement. So measurements for two sensors can be sent together.</p>"},{"location":"#api","title":"API","text":"<p>It is possible to connect to the Server via a SocketIO api. A brief documentation can be found here. More information may follow.</p>"},{"location":"source/database/","title":"Database","text":"<p>Module for databases.</p> <p>Database implementation for saving, loading and preprocess measurements.</p>"},{"location":"source/database/#database.database","title":"<code>database</code>","text":"<p>Database implementation.</p>"},{"location":"source/database/#database.database.Measurement","title":"<code> Measurement            (dict)         </code>","text":"<p>Typed Dictionary for one measurement.</p> Source code in <code>database/database.py</code> <pre><code>class Measurement(TypedDict):\n\"\"\"Typed Dictionary for one measurement.\"\"\"\nts: int\nname: str\nvalue: float\n</code></pre>"},{"location":"source/database/#database.database.MeasurementDB","title":"<code> MeasurementDB        </code>","text":"<p>Measurement Database.</p> <p>Saving, loading and preprocessing of measurement data. The data is saved as csv files.</p> Source code in <code>database/database.py</code> <pre><code>class MeasurementDB:\n\"\"\"Measurement Database.\n    Saving, loading and preprocessing of measurement data.\n    The data is saved as csv files.\n    \"\"\"\ndef __init__(self) -&gt; None:\n\"\"\"Initialize the database.\"\"\"\nself.db_1 = pd.DataFrame(columns=[\"ts\", \"name\", \"value\"])\nself.db_2 = pd.DataFrame(columns=[\"ts\", \"name\", \"value\"])\nself.last_save_ts = 0.0\nself.db_name = time.strftime(\"%Y_%m_%d_%H_%M\")\ndef append(self, meas_data: List[Measurement]) -&gt; None:\n\"\"\"Append measurements to the database.\n        The measurement are added to the database.\n        Args:\n            meas_data (List[Measurement]): List of measurements to append.\n        \"\"\"\nfor data in meas_data:\nif data[\"name\"] == \"1\":\nself.db_1 = pd.concat(\n[self.db_1, pd.DataFrame(data, index=[0])], ignore_index=True\n)\nelif data[\"name\"] == \"2\":\nself.db_2 = pd.concat(\n[self.db_2, pd.DataFrame(data, index=[0])], ignore_index=True\n)\nif time.time() &gt; self.last_save_ts + 60.0:\nself.last_save_ts = time.time()\nself.db_1.to_csv(\"./data/\" + self.db_name + \"_db_1.csv\")\nself.db_2.to_csv(\"./data/\" + self.db_name + \"_db_2.csv\")\ndef getBetweenTime(\nself, start: Union[str, float, int], stop: Optional[str] = None\n) -&gt; str:\n\"\"\"Get all data between two timepoints.\n        Return all data from start time to stop time as a string.\n        If stop is none up to the latest data is returned\n        Args:\n            start (Union[str, float, int]): start time\n            stop (str, optional): stop time. Defaults to None.\n        Returns:\n            str: containing all data\n        \"\"\"\nself.db_1.sort_values(by=\"ts\", ascending=True, inplace=True)\nself.db_2.sort_values(by=\"ts\", ascending=True, inplace=True)\nstart_time = pd.to_datetime(start)\nif stop is None:\nstop_time = None\nelse:\nstop_time = pd.to_datetime(stop)\ntemp_1_db = self.db_1.copy()\ntemp_1_db[\"DateTime\"] = pd.to_datetime(temp_1_db[\"ts\"])\ntemp_1_db = temp_1_db.set_index(\"DateTime\")\ntemp_1_db = temp_1_db[start_time:stop_time]\ntemp_2_db = self.db_2.copy()\ntemp_2_db[\"DateTime\"] = pd.to_datetime(temp_2_db[\"ts\"])\ntemp_2_db = temp_2_db.set_index(\"DateTime\")\ntemp_2_db = temp_2_db[start_time:stop_time]\ntemp_1_str = temp_1_db[[\"ts\", \"value\"]].to_json(orient=\"values\")\ntemp_2_str = temp_2_db[[\"ts\", \"value\"]].to_json(orient=\"values\")\nreturn f\"[{temp_1_str} , {temp_2_str} ]\"\ndef getInterpolBetweenTime(\nself, dt: float, start: Union[str, int], stop: Optional[str] = None\n) -&gt; Tuple[List[float], List[float]]:\n\"\"\"Get data between to timepoints interpolated to a uniform timegrid.\n        The data between start and stop is interpolated to a uniform time grid\n        with a specific time delta.\n        If no stop time is specified up to the latest data is returned.\n        Args:\n            dt (float): time difference of the uniform grid.\n            start (str): start time.\n            stop (str, optional): stop time. Defaults to None.\n        Returns:\n            List[List[float], List[float]]: First and second measurements.\n        \"\"\"\nself.db_1.sort_values(by=\"ts\", ascending=True, inplace=True)\nself.db_2.sort_values(by=\"ts\", ascending=True, inplace=True)\nstart_time = pd.to_datetime(start)\nif stop is None:\nstop_time = None\nelse:\nstop_time = pd.to_datetime(stop)\ntemp_1_db = self.db_1.copy()\ntemp_1_db[\"DateTime\"] = pd.to_datetime(temp_1_db[\"ts\"])\ntemp_1_db = temp_1_db.set_index(\"DateTime\")\ntemp_1_db = temp_1_db[start_time:stop_time]\ntemp_1_db = (\ntemp_1_db[\"value\"]\n.resample(pd.to_timedelta(dt, unit=\"s\"), origin=start)\n.mean()\n)\ntemp_2_db = self.db_2.copy()\ntemp_2_db[\"DateTime\"] = pd.to_datetime(temp_2_db[\"ts\"])\ntemp_2_db = temp_2_db.set_index(\"DateTime\")\ntemp_2_db = temp_2_db[start_time:stop_time]\ntemp_2_db = (\ntemp_2_db[\"value\"]\n.resample(pd.to_timedelta(dt, unit=\"s\"), origin=start)\n.mean()\n)\nreturn temp_1_db.to_list(), temp_2_db.to_list()\n</code></pre>"},{"location":"source/database/#database.database.MeasurementDB.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize the database.</p> Source code in <code>database/database.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the database.\"\"\"\nself.db_1 = pd.DataFrame(columns=[\"ts\", \"name\", \"value\"])\nself.db_2 = pd.DataFrame(columns=[\"ts\", \"name\", \"value\"])\nself.last_save_ts = 0.0\nself.db_name = time.strftime(\"%Y_%m_%d_%H_%M\")\n</code></pre>"},{"location":"source/database/#database.database.MeasurementDB.append","title":"<code>append(self, meas_data)</code>","text":"<p>Append measurements to the database.</p> <p>The measurement are added to the database.</p> <p>Parameters:</p> Name Type Description Default <code>meas_data</code> <code>List[Measurement]</code> <p>List of measurements to append.</p> required Source code in <code>database/database.py</code> <pre><code>def append(self, meas_data: List[Measurement]) -&gt; None:\n\"\"\"Append measurements to the database.\n    The measurement are added to the database.\n    Args:\n        meas_data (List[Measurement]): List of measurements to append.\n    \"\"\"\nfor data in meas_data:\nif data[\"name\"] == \"1\":\nself.db_1 = pd.concat(\n[self.db_1, pd.DataFrame(data, index=[0])], ignore_index=True\n)\nelif data[\"name\"] == \"2\":\nself.db_2 = pd.concat(\n[self.db_2, pd.DataFrame(data, index=[0])], ignore_index=True\n)\nif time.time() &gt; self.last_save_ts + 60.0:\nself.last_save_ts = time.time()\nself.db_1.to_csv(\"./data/\" + self.db_name + \"_db_1.csv\")\nself.db_2.to_csv(\"./data/\" + self.db_name + \"_db_2.csv\")\n</code></pre>"},{"location":"source/database/#database.database.MeasurementDB.getBetweenTime","title":"<code>getBetweenTime(self, start, stop=None)</code>","text":"<p>Get all data between two timepoints.</p> <p>Return all data from start time to stop time as a string. If stop is none up to the latest data is returned</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Union[str, float, int]</code> <p>start time</p> required <code>stop</code> <code>str</code> <p>stop time. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>containing all data</p> Source code in <code>database/database.py</code> <pre><code>def getBetweenTime(\nself, start: Union[str, float, int], stop: Optional[str] = None\n) -&gt; str:\n\"\"\"Get all data between two timepoints.\n    Return all data from start time to stop time as a string.\n    If stop is none up to the latest data is returned\n    Args:\n        start (Union[str, float, int]): start time\n        stop (str, optional): stop time. Defaults to None.\n    Returns:\n        str: containing all data\n    \"\"\"\nself.db_1.sort_values(by=\"ts\", ascending=True, inplace=True)\nself.db_2.sort_values(by=\"ts\", ascending=True, inplace=True)\nstart_time = pd.to_datetime(start)\nif stop is None:\nstop_time = None\nelse:\nstop_time = pd.to_datetime(stop)\ntemp_1_db = self.db_1.copy()\ntemp_1_db[\"DateTime\"] = pd.to_datetime(temp_1_db[\"ts\"])\ntemp_1_db = temp_1_db.set_index(\"DateTime\")\ntemp_1_db = temp_1_db[start_time:stop_time]\ntemp_2_db = self.db_2.copy()\ntemp_2_db[\"DateTime\"] = pd.to_datetime(temp_2_db[\"ts\"])\ntemp_2_db = temp_2_db.set_index(\"DateTime\")\ntemp_2_db = temp_2_db[start_time:stop_time]\ntemp_1_str = temp_1_db[[\"ts\", \"value\"]].to_json(orient=\"values\")\ntemp_2_str = temp_2_db[[\"ts\", \"value\"]].to_json(orient=\"values\")\nreturn f\"[{temp_1_str} , {temp_2_str} ]\"\n</code></pre>"},{"location":"source/database/#database.database.MeasurementDB.getInterpolBetweenTime","title":"<code>getInterpolBetweenTime(self, dt, start, stop=None)</code>","text":"<p>Get data between to timepoints interpolated to a uniform timegrid.</p> <p>The data between start and stop is interpolated to a uniform time grid with a specific time delta. If no stop time is specified up to the latest data is returned.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>time difference of the uniform grid.</p> required <code>start</code> <code>str</code> <p>start time.</p> required <code>stop</code> <code>str</code> <p>stop time. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[List[float], List[float]]</code> <p>First and second measurements.</p> Source code in <code>database/database.py</code> <pre><code>def getInterpolBetweenTime(\nself, dt: float, start: Union[str, int], stop: Optional[str] = None\n) -&gt; Tuple[List[float], List[float]]:\n\"\"\"Get data between to timepoints interpolated to a uniform timegrid.\n    The data between start and stop is interpolated to a uniform time grid\n    with a specific time delta.\n    If no stop time is specified up to the latest data is returned.\n    Args:\n        dt (float): time difference of the uniform grid.\n        start (str): start time.\n        stop (str, optional): stop time. Defaults to None.\n    Returns:\n        List[List[float], List[float]]: First and second measurements.\n    \"\"\"\nself.db_1.sort_values(by=\"ts\", ascending=True, inplace=True)\nself.db_2.sort_values(by=\"ts\", ascending=True, inplace=True)\nstart_time = pd.to_datetime(start)\nif stop is None:\nstop_time = None\nelse:\nstop_time = pd.to_datetime(stop)\ntemp_1_db = self.db_1.copy()\ntemp_1_db[\"DateTime\"] = pd.to_datetime(temp_1_db[\"ts\"])\ntemp_1_db = temp_1_db.set_index(\"DateTime\")\ntemp_1_db = temp_1_db[start_time:stop_time]\ntemp_1_db = (\ntemp_1_db[\"value\"]\n.resample(pd.to_timedelta(dt, unit=\"s\"), origin=start)\n.mean()\n)\ntemp_2_db = self.db_2.copy()\ntemp_2_db[\"DateTime\"] = pd.to_datetime(temp_2_db[\"ts\"])\ntemp_2_db = temp_2_db.set_index(\"DateTime\")\ntemp_2_db = temp_2_db[start_time:stop_time]\ntemp_2_db = (\ntemp_2_db[\"value\"]\n.resample(pd.to_timedelta(dt, unit=\"s\"), origin=start)\n.mean()\n)\nreturn temp_1_db.to_list(), temp_2_db.to_list()\n</code></pre>"},{"location":"source/input/","title":"Input","text":"<p>Module for measurement input classes.</p> <p>This module holds different classes to receive measurement input and parse them.</p>"},{"location":"source/input/#input.measurement_parser","title":"<code>measurement_parser</code>","text":"<p>Implementation of a parser for string measurements.</p>"},{"location":"source/input/#input.measurement_parser.parse_string","title":"<code>parse_string(data)</code>","text":"<p>Parse a measurement string to a measurement.</p> <p>The string is formatted as: Measurement,device=TempSens,Sensor= value=  is the number of the sensor 1 or 2.  is the measured value as float.  is the timestamp in ns since epoch. The timestamp is optional. If no timestamp is given the current time is used. After each Measurement a newline indicates a new Measurement. <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>string received via http POST.</p> required <p>Returns:</p> Type Description <code>List[Measurement]</code> <p>Parsed measurements.</p> Source code in <code>input/measurement_parser.py</code> <pre><code>def parse_string(data: str) -&gt; List[Measurement]:\n\"\"\"Parse a measurement string to a measurement.\n    The string is formatted as:\n    Measurement,device=TempSens,Sensor=&lt;name&gt; value=&lt;val&gt; &lt;ts&gt;\n    &lt;name&gt; is the number of the sensor 1 or 2.\n    &lt;val&gt; is the measured value as float.\n    &lt;ts&gt; is the timestamp in ns since epoch. The timestamp is optional.\n    If no timestamp is given the current time is used.\n    After each Measurement a newline indicates a new Measurement.\n    Args:\n        data (str): string received via http POST.\n    Returns:\n        List[Measurement]: Parsed measurements.\n    \"\"\"\ntemp_list = str(data).strip().split(\"\\n\")\nnew_sensor_data: List[Measurement] = []\nfor sensor_data in temp_list:\nsensor_data_splitted = sensor_data.split(\" \")\nsensor_name = \"\"\nsensor_value = 0.0\nif len(sensor_data_splitted) &gt; 2:\nsensor_ts = int(sensor_data_splitted[-1])\nelse:\nsensor_ts = round(time() * 1e9)\nfor sensor_data_values in sensor_data_splitted:\nif sensor_data_values.startswith(\"value\"):\nsensor_value = float(sensor_data_values.split(\"value=\")[1])\nif sensor_data_values.startswith(\"Measurement,device=TempSens,Sensor=\"):\nsensor_name = sensor_data_values.split(\n\"Measurement,device=TempSens,Sensor=\"\n)[1]\nnew_sensor_data.append(\n{\"name\": sensor_name, \"value\": sensor_value, \"ts\": sensor_ts}\n)\nreturn new_sensor_data\n</code></pre>"},{"location":"source/models/","title":"Models","text":"<p>Module for models.</p> <p>Implementation of different models for fitting and prediction.</p>"},{"location":"source/models/#models.fourier_series_model","title":"<code>fourier_series_model</code>","text":"<p>Implementation of a Fourier Model.</p>"},{"location":"source/models/#models.fourier_series_model.FourierSeriesModel","title":"<code> FourierSeriesModel        </code>","text":"<p>Fourier Series Model.</p> <p>This model implements a fourier series sum. It is able to approximate any periodic function with a series of sin and cosine functions.</p> Source code in <code>models/fourier_series_model.py</code> <pre><code>class FourierSeriesModel:\n\"\"\"Fourier Series Model.\n    This model implements a fourier series sum. It is able to\n    approximate any periodic function with a series of sin and\n    cosine functions.\n    \"\"\"\ndef __init__(self, num_functions: int) -&gt; None:\n\"\"\"Initialize the Model.\n        This model approximates any periodic function with a series of\n        sin and cosine functions.\n        Using more functions leads to a better approximation but tends to overfitting.\n        Args:\n            num_functions (int): Number sin and cosine functions.\n        \"\"\"\nself.num_functions = num_functions\nt_sim = cad.SX.sym(\"t_sim\", 1)\namp_sim = cad.SX.sym(\"amp_sim\", (self.num_functions, 2))\nw_0_sim = cad.SX.sym(\"w_0_sim\", 1)\nbias_sim = cad.SX.sym(\"bias_sim\", 1)\nphase_sim = cad.SX.sym(\"phase_sim\", 1)\ntemp_sim = self.func_casadi(t_sim, amp_sim, w_0_sim, bias_sim, phase_sim)\nself.casadi_fun = cad.Function(\n\"temp_func\",\n[t_sim, amp_sim, w_0_sim, bias_sim, phase_sim],\n[temp_sim],\n[\"t_sim\", \"amp_sim\", \"w_0_sim\", \"bias_sim\", \"phase_sim\"],\n[\n\"temp_sim\",\n],\n)\ndef func_casadi(self, t, amplitudes, w_0, bias, phase):\nvalue = bias\nfor i in range(amplitudes.shape[0]):\nvalue += amplitudes[i, 0] * cad.cos(w_0 * (i + 1) * t + phase) + amplitudes[\ni, 1\n] * cad.sin(w_0 * (i + 1) * t + phase)\nreturn value\ndef func(self, t, amplitudes, w_0, bias, phase):\ntemp = self.casadi_fun(t, amplitudes, w_0, bias, phase).full().flatten()[0]\nreturn temp\n</code></pre>"},{"location":"source/models/#models.fourier_series_model.FourierSeriesModel.__init__","title":"<code>__init__(self, num_functions)</code>  <code>special</code>","text":"<p>Initialize the Model.</p> <p>This model approximates any periodic function with a series of sin and cosine functions. Using more functions leads to a better approximation but tends to overfitting.</p> <p>Parameters:</p> Name Type Description Default <code>num_functions</code> <code>int</code> <p>Number sin and cosine functions.</p> required Source code in <code>models/fourier_series_model.py</code> <pre><code>def __init__(self, num_functions: int) -&gt; None:\n\"\"\"Initialize the Model.\n    This model approximates any periodic function with a series of\n    sin and cosine functions.\n    Using more functions leads to a better approximation but tends to overfitting.\n    Args:\n        num_functions (int): Number sin and cosine functions.\n    \"\"\"\nself.num_functions = num_functions\nt_sim = cad.SX.sym(\"t_sim\", 1)\namp_sim = cad.SX.sym(\"amp_sim\", (self.num_functions, 2))\nw_0_sim = cad.SX.sym(\"w_0_sim\", 1)\nbias_sim = cad.SX.sym(\"bias_sim\", 1)\nphase_sim = cad.SX.sym(\"phase_sim\", 1)\ntemp_sim = self.func_casadi(t_sim, amp_sim, w_0_sim, bias_sim, phase_sim)\nself.casadi_fun = cad.Function(\n\"temp_func\",\n[t_sim, amp_sim, w_0_sim, bias_sim, phase_sim],\n[temp_sim],\n[\"t_sim\", \"amp_sim\", \"w_0_sim\", \"bias_sim\", \"phase_sim\"],\n[\n\"temp_sim\",\n],\n)\n</code></pre>"},{"location":"source/models/#models.fourier_series_model.FourierSeriesModel.func","title":"<code>func(self, t, amplitudes, w_0, bias, phase)</code>","text":"Source code in <code>models/fourier_series_model.py</code> <pre><code>def func(self, t, amplitudes, w_0, bias, phase):\ntemp = self.casadi_fun(t, amplitudes, w_0, bias, phase).full().flatten()[0]\nreturn temp\n</code></pre>"},{"location":"source/models/#models.fourier_series_model.FourierSeriesModel.func_casadi","title":"<code>func_casadi(self, t, amplitudes, w_0, bias, phase)</code>","text":"Source code in <code>models/fourier_series_model.py</code> <pre><code>def func_casadi(self, t, amplitudes, w_0, bias, phase):\nvalue = bias\nfor i in range(amplitudes.shape[0]):\nvalue += amplitudes[i, 0] * cad.cos(w_0 * (i + 1) * t + phase) + amplitudes[\ni, 1\n] * cad.sin(w_0 * (i + 1) * t + phase)\nreturn value\n</code></pre>"},{"location":"source/models/#models.meat_estimator","title":"<code>meat_estimator</code>","text":"<p>Implementation of meat identification.</p>"},{"location":"source/models/#models.meat_estimator.MeatEstimator","title":"<code> MeatEstimator        </code>","text":"<p>Estimates the temperature and model parameter for the meat.</p> Source code in <code>models/meat_estimator.py</code> <pre><code>class MeatEstimator:\n\"\"\"Estimates the temperature and model parameter for the meat.\"\"\"\ndef __init__(self, dt: float, num_elements: int) -&gt; None:\n\"\"\"Initialize the estimator.\"\"\"\nself._num_elements = num_elements\nself._dt = dt\nself._model = MeatModel(self._num_elements)\nself.last_x_init = None\ndef fit_params(\nself, meas_inner: List[float], meas_outer: List[float]\n) -&gt; Tuple[float, np.ndarray]:\n\"\"\"Fit meat parameter to measurements.\n        Args:\n            meas_inner (List[float]): Measurements of the core temperature.\n            meas_outer (List[float]): Measurements of the oven temperature.\n        Returns:\n            Tuple[float,np.ndarray]: meat resistance param r, temperature states.\n        \"\"\"\nx_init: List[Union[float, np.ndarray]] = []\nr = cad.SX.sym(\"r\")\nx_init.append(1.0)\ng: List[Union[float, np.ndarray]] = [r]\nlbg: List[Union[float, np.ndarray]] = [0.0]\nubg: List[Union[float, np.ndarray]] = [40.0]\nx_0 = cad.SX.sym(\"x_0\", self._num_elements)\nw = [r, x_0]\nx_init.append(np.zeros(self._num_elements))\nf = (x_0[self._num_elements - 1] - meas_inner[0]) ** 2\nfor i in range(self._num_elements - 1):\ng.append(x_0[i] - x_0[i + 1])\nlbg.append(0.0)\nubg.append(cad.inf)\nfor i in range(self._num_elements):\ng.append(x_0[i])\nlbg.append(0.0)\nubg.append(60.0)\nx_curr = x_0\nfor i in range(len(meas_inner) - 1):\nx_sym = cad.SX.sym(\"x_\" + str(i + 1), self._num_elements)\nw.append(x_sym)\nx_init.append(\nnp.linspace(meas_outer[i], meas_inner[i + 1], self._num_elements)\n)\nx_next = self._model.casadi_fun(x_curr, meas_outer[i], r, self._dt)\ng.append(x_sym - x_next)\nlbg.append(np.zeros(self._num_elements))\nubg.append(np.zeros(self._num_elements))\ng.append(x_curr)\nlbg.append(np.zeros(self._num_elements))\nubg.append(200.0 * np.ones(self._num_elements))\nf += (x_sym[self._num_elements - 1] - meas_inner[i + 1]) ** 2\nx_curr = x_sym\ng.append(x_curr)\nlbg.append(np.zeros(self._num_elements))\nubg.append(200.0 * np.ones(self._num_elements))\nqp = {\"x\": cad.vertcat(*w), \"f\": f, \"g\": cad.vertcat(*g)}\nsolver = cad.nlpsol(\"Solver\", \"ipopt\", qp)\nx_init = cad.vertcat(*x_init)\nif self.last_x_init is not None:\nx_init[: self.last_x_init.shape[0]] = self.last_x_init\nsol = solver(x0=x_init, lbg=cad.vertcat(*lbg), ubg=cad.vertcat(*ubg))\nr = sol[\"x\"][0]\nself.last_x_init = sol[\"x\"].full().flatten()\nstates = np.reshape(np.array(sol[\"x\"][1:]), (-1, self._num_elements))\nreturn r, states\n</code></pre>"},{"location":"source/models/#models.meat_estimator.MeatEstimator.__init__","title":"<code>__init__(self, dt, num_elements)</code>  <code>special</code>","text":"<p>Initialize the estimator.</p> Source code in <code>models/meat_estimator.py</code> <pre><code>def __init__(self, dt: float, num_elements: int) -&gt; None:\n\"\"\"Initialize the estimator.\"\"\"\nself._num_elements = num_elements\nself._dt = dt\nself._model = MeatModel(self._num_elements)\nself.last_x_init = None\n</code></pre>"},{"location":"source/models/#models.meat_estimator.MeatEstimator.fit_params","title":"<code>fit_params(self, meas_inner, meas_outer)</code>","text":"<p>Fit meat parameter to measurements.</p> <p>Parameters:</p> Name Type Description Default <code>meas_inner</code> <code>List[float]</code> <p>Measurements of the core temperature.</p> required <code>meas_outer</code> <code>List[float]</code> <p>Measurements of the oven temperature.</p> required <p>Returns:</p> Type Description <code>Tuple[float,np.ndarray]</code> <p>meat resistance param r, temperature states.</p> Source code in <code>models/meat_estimator.py</code> <pre><code>def fit_params(\nself, meas_inner: List[float], meas_outer: List[float]\n) -&gt; Tuple[float, np.ndarray]:\n\"\"\"Fit meat parameter to measurements.\n    Args:\n        meas_inner (List[float]): Measurements of the core temperature.\n        meas_outer (List[float]): Measurements of the oven temperature.\n    Returns:\n        Tuple[float,np.ndarray]: meat resistance param r, temperature states.\n    \"\"\"\nx_init: List[Union[float, np.ndarray]] = []\nr = cad.SX.sym(\"r\")\nx_init.append(1.0)\ng: List[Union[float, np.ndarray]] = [r]\nlbg: List[Union[float, np.ndarray]] = [0.0]\nubg: List[Union[float, np.ndarray]] = [40.0]\nx_0 = cad.SX.sym(\"x_0\", self._num_elements)\nw = [r, x_0]\nx_init.append(np.zeros(self._num_elements))\nf = (x_0[self._num_elements - 1] - meas_inner[0]) ** 2\nfor i in range(self._num_elements - 1):\ng.append(x_0[i] - x_0[i + 1])\nlbg.append(0.0)\nubg.append(cad.inf)\nfor i in range(self._num_elements):\ng.append(x_0[i])\nlbg.append(0.0)\nubg.append(60.0)\nx_curr = x_0\nfor i in range(len(meas_inner) - 1):\nx_sym = cad.SX.sym(\"x_\" + str(i + 1), self._num_elements)\nw.append(x_sym)\nx_init.append(\nnp.linspace(meas_outer[i], meas_inner[i + 1], self._num_elements)\n)\nx_next = self._model.casadi_fun(x_curr, meas_outer[i], r, self._dt)\ng.append(x_sym - x_next)\nlbg.append(np.zeros(self._num_elements))\nubg.append(np.zeros(self._num_elements))\ng.append(x_curr)\nlbg.append(np.zeros(self._num_elements))\nubg.append(200.0 * np.ones(self._num_elements))\nf += (x_sym[self._num_elements - 1] - meas_inner[i + 1]) ** 2\nx_curr = x_sym\ng.append(x_curr)\nlbg.append(np.zeros(self._num_elements))\nubg.append(200.0 * np.ones(self._num_elements))\nqp = {\"x\": cad.vertcat(*w), \"f\": f, \"g\": cad.vertcat(*g)}\nsolver = cad.nlpsol(\"Solver\", \"ipopt\", qp)\nx_init = cad.vertcat(*x_init)\nif self.last_x_init is not None:\nx_init[: self.last_x_init.shape[0]] = self.last_x_init\nsol = solver(x0=x_init, lbg=cad.vertcat(*lbg), ubg=cad.vertcat(*ubg))\nr = sol[\"x\"][0]\nself.last_x_init = sol[\"x\"].full().flatten()\nstates = np.reshape(np.array(sol[\"x\"][1:]), (-1, self._num_elements))\nreturn r, states\n</code></pre>"},{"location":"source/models/#models.meat_model","title":"<code>meat_model</code>","text":"<p>Model implementation of the meat</p>"},{"location":"source/models/#models.meat_model.MeatModel","title":"<code> MeatModel        </code>","text":"<p>Model defining the temperature in the meat</p> Source code in <code>models/meat_model.py</code> <pre><code>class MeatModel:\n\"\"\"Model defining the temperature in the meat\"\"\"\ndef __init__(self, num_elemnets: int = 10) -&gt; None:\n\"\"\"Initialize the meat model.\n        Args:\n            num_elemnets (int, optional): number of elements. Defaults to 10.\n        \"\"\"\nself._num_elements = num_elemnets\nx_sim_meat = cad.SX.sym(\"x_sim_meat\", self._num_elements)\nu_sim_meat = cad.SX.sym(\"u_sim_meat\", 1)\nr_sim_meat = cad.SX.sym(\"r_sim_meat\", 1)\ndt_sim_meat = cad.SX.sym(\"dt_sim_meat\", 1)\nx_next = self.next_state_casadi(x_sim_meat, u_sim_meat, r_sim_meat, dt_sim_meat)\nself.casadi_fun = cad.Function(\n\"next_state\",\n[x_sim_meat, u_sim_meat, r_sim_meat, dt_sim_meat],\n[x_next],\n[\"x0_sim_meat\", \"u_sim_meat\", \"r_sim_meat\", \"dt_sim_meat\"],\n[\n\"x_next\",\n],\n)\ndef ode_casadi(self, x, u, r):\ndT = []\nr_scaled = 1 / (r * self._num_elements)\ndT.append(r_scaled * (u / 2.0 - x[0] + x[1] / 2.0))\nfor i in range(1, self._num_elements - 1):\ndT.append(r_scaled * (x[i - 1] / 2.0 - x[i] + x[i + 1] / 2.0))\ndT.append(r_scaled * (x[self._num_elements - 2] - x[self._num_elements - 1]))\nreturn cad.vertcat(*dT)\ndef next_state_casadi(self, x, u, r, dt):\nx_next = self.rk4(self.ode_casadi, x, u, r, dt)\nreturn x_next\ndef ode(self, x, u, r):\n\"\"\"\n        state = T\n        dT_k = 1/2 * r * (T_k-1 - T_k) + 1/2 * r * (T_k+1 - T_k)\n           = -r*T_k + 1/2 r * (T_k-1 + T_k+1)\n           = r * (1/2 T_k-1 - T_k + 1/2 T_k+1)\n        dT_0 = 1/2* r* (u - T_0) + 1/2* r * (T_1 - T_0)\n             = r (1/2 u -T_0 + 1/2 T_1)\n        dT_N = r(T_N-1 - T_N)\n        \"\"\"\ndT = []\nr_scaled = 1 / (r * self._num_elements)\ndT.append(r_scaled * (u / 2.0 - x[0] + x[1] / 2.0))\nfor i in range(1, self._num_elements - 1):\ndT.append(r_scaled * (x[i - 1] / 2.0 - x[i] + x[i + 1] / 2.0))\ndT.append(r_scaled * (x[self._num_elements - 2] - x[self._num_elements - 1]))\nreturn np.array(dT)\ndef next_state(self, x, u, r, dt):\n# x_next = self.rk4(self.ode,x,u,r, dt)\nx_next = np.array(self.casadi_fun(x, u, r, dt).full().flatten())\nreturn x_next\ndef rk4(self, ode, x, u, r, dt):\nsteps = 5\ndt_step = dt / steps\nx_next = x\nfor j in range(steps):\nk1 = ode(x_next, u, r)\nk2 = ode(x_next + dt_step / 2.0 * k1, u, r)\nk3 = ode(x_next + dt_step / 2.0 * k2, u, r)\nk4 = ode(x_next + dt_step * k3, u, r)\nx_next = x_next + dt_step / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\nreturn x_next\n</code></pre>"},{"location":"source/models/#models.meat_model.MeatModel.__init__","title":"<code>__init__(self, num_elemnets=10)</code>  <code>special</code>","text":"<p>Initialize the meat model.</p> <p>Parameters:</p> Name Type Description Default <code>num_elemnets</code> <code>int</code> <p>number of elements. Defaults to 10.</p> <code>10</code> Source code in <code>models/meat_model.py</code> <pre><code>def __init__(self, num_elemnets: int = 10) -&gt; None:\n\"\"\"Initialize the meat model.\n    Args:\n        num_elemnets (int, optional): number of elements. Defaults to 10.\n    \"\"\"\nself._num_elements = num_elemnets\nx_sim_meat = cad.SX.sym(\"x_sim_meat\", self._num_elements)\nu_sim_meat = cad.SX.sym(\"u_sim_meat\", 1)\nr_sim_meat = cad.SX.sym(\"r_sim_meat\", 1)\ndt_sim_meat = cad.SX.sym(\"dt_sim_meat\", 1)\nx_next = self.next_state_casadi(x_sim_meat, u_sim_meat, r_sim_meat, dt_sim_meat)\nself.casadi_fun = cad.Function(\n\"next_state\",\n[x_sim_meat, u_sim_meat, r_sim_meat, dt_sim_meat],\n[x_next],\n[\"x0_sim_meat\", \"u_sim_meat\", \"r_sim_meat\", \"dt_sim_meat\"],\n[\n\"x_next\",\n],\n)\n</code></pre>"},{"location":"source/models/#models.meat_model.MeatModel.next_state","title":"<code>next_state(self, x, u, r, dt)</code>","text":"Source code in <code>models/meat_model.py</code> <pre><code>def next_state(self, x, u, r, dt):\n# x_next = self.rk4(self.ode,x,u,r, dt)\nx_next = np.array(self.casadi_fun(x, u, r, dt).full().flatten())\nreturn x_next\n</code></pre>"},{"location":"source/models/#models.meat_model.MeatModel.next_state_casadi","title":"<code>next_state_casadi(self, x, u, r, dt)</code>","text":"Source code in <code>models/meat_model.py</code> <pre><code>def next_state_casadi(self, x, u, r, dt):\nx_next = self.rk4(self.ode_casadi, x, u, r, dt)\nreturn x_next\n</code></pre>"},{"location":"source/models/#models.meat_model.MeatModel.ode","title":"<code>ode(self, x, u, r)</code>","text":"<p>state = T dT_k = 1/2 * r * (T_k-1 - T_k) + 1/2 * r * (T_k+1 - T_k)    = -r*T_k + 1/2 r * (T_k-1 + T_k+1)    = r * (1/2 T_k-1 - T_k + 1/2 T_k+1)</p> <p>dT_0 = 1/2 r (u - T_0) + 1/2* r * (T_1 - T_0)      = r (1/2 u -T_0 + 1/2 T_1)</p> <p>dT_N = r(T_N-1 - T_N)</p> Source code in <code>models/meat_model.py</code> <pre><code>def ode(self, x, u, r):\n\"\"\"\n    state = T\n    dT_k = 1/2 * r * (T_k-1 - T_k) + 1/2 * r * (T_k+1 - T_k)\n       = -r*T_k + 1/2 r * (T_k-1 + T_k+1)\n       = r * (1/2 T_k-1 - T_k + 1/2 T_k+1)\n    dT_0 = 1/2* r* (u - T_0) + 1/2* r * (T_1 - T_0)\n         = r (1/2 u -T_0 + 1/2 T_1)\n    dT_N = r(T_N-1 - T_N)\n    \"\"\"\ndT = []\nr_scaled = 1 / (r * self._num_elements)\ndT.append(r_scaled * (u / 2.0 - x[0] + x[1] / 2.0))\nfor i in range(1, self._num_elements - 1):\ndT.append(r_scaled * (x[i - 1] / 2.0 - x[i] + x[i + 1] / 2.0))\ndT.append(r_scaled * (x[self._num_elements - 2] - x[self._num_elements - 1]))\nreturn np.array(dT)\n</code></pre>"},{"location":"source/models/#models.meat_model.MeatModel.ode_casadi","title":"<code>ode_casadi(self, x, u, r)</code>","text":"Source code in <code>models/meat_model.py</code> <pre><code>def ode_casadi(self, x, u, r):\ndT = []\nr_scaled = 1 / (r * self._num_elements)\ndT.append(r_scaled * (u / 2.0 - x[0] + x[1] / 2.0))\nfor i in range(1, self._num_elements - 1):\ndT.append(r_scaled * (x[i - 1] / 2.0 - x[i] + x[i + 1] / 2.0))\ndT.append(r_scaled * (x[self._num_elements - 2] - x[self._num_elements - 1]))\nreturn cad.vertcat(*dT)\n</code></pre>"},{"location":"source/models/#models.meat_model.MeatModel.rk4","title":"<code>rk4(self, ode, x, u, r, dt)</code>","text":"Source code in <code>models/meat_model.py</code> <pre><code>def rk4(self, ode, x, u, r, dt):\nsteps = 5\ndt_step = dt / steps\nx_next = x\nfor j in range(steps):\nk1 = ode(x_next, u, r)\nk2 = ode(x_next + dt_step / 2.0 * k1, u, r)\nk3 = ode(x_next + dt_step / 2.0 * k2, u, r)\nk4 = ode(x_next + dt_step * k3, u, r)\nx_next = x_next + dt_step / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\nreturn x_next\n</code></pre>"},{"location":"source/models/#models.oven_estimator","title":"<code>oven_estimator</code>","text":""},{"location":"source/models/#models.oven_estimator.OvenEstimator","title":"<code> OvenEstimator        </code>","text":"Source code in <code>models/oven_estimator.py</code> <pre><code>class OvenEstimator:\ndef __init__(self, dt: float, num_functions: int) -&gt; None:\nself._dt = dt\nself._num_functions = num_functions\nself._model = FourierSeriesModel(self._num_functions)\nself.last_x_init = None\ndef get_frequency(self, measurements):\n\"\"\" \"\"\"\nmeas = np.array(measurements)\nbias = np.mean(measurements)\nmeas[meas &lt; bias] = -1\nmeas[meas &gt;= bias] = 1\ndiff = np.abs(np.diff(meas))\nindex_changes = np.where(diff &gt; 1)[0]\nprint(\"changes_before\", index_changes)\n# add logic for filtering\nif index_changes.shape[0] &gt; 1:\nlast_index = index_changes[0]\nfiltered_changes = [last_index]\nfor i in range(1, index_changes.shape[0]):\ncurr_diff = index_changes[i] - last_index\nif curr_diff &gt; 15:\nfiltered_changes.append(index_changes[i])\nlast_index = index_changes[i]\nindex_changes = np.array(filtered_changes)\nprint(\"changes_after\", index_changes)\nsteps = 0\nif index_changes.shape[0] == 1:\nsteps = np.max([index_changes * 2.0, meas.shape[0]])\nelif index_changes.shape[0] == 2:\nsteps = np.max([index_changes[1] - index_changes[0], meas.shape[0]])\nelse:\ndiff_indices = np.diff(index_changes)\nphase_1 = diff_indices[::2]\nphase_2 = diff_indices[1::2]\nsteps = np.mean(phase_1) + np.mean(phase_2)\nif steps == 0:\nw = 0.0\nelse:\nw = 2 * np.pi / (steps * self._dt)\nreturn bias, w\ndef fit_params(\nself, outer_measurements: List[float]\n) -&gt; Tuple[np.ndarray, float, float, float]:\nbias_calc, w_calc = self.get_frequency(outer_measurements)\nx_init = []\nw = []\nbias = cad.SX.sym(\"bias\", 1)\nw.append(bias)\nx_init.append(bias_calc)\nphase = 0\nw_0 = w_calc\namplitudes = cad.SX.sym(\"amplitudes\", (self._num_functions, 2))\nw += cad.horzsplit(amplitudes)\nx_init.append([0.010, 0.01] * self._num_functions)\nf = 0\nfor i in range(len(outer_measurements)):\nf += (\n1.001**i\n* (\nouter_measurements[i]\n- self._model.casadi_fun(i * self._dt, amplitudes, w_0, bias, phase)\n)\n** 2.0\n)\nqp = {\n\"x\": cad.vertcat(*w),\n\"f\": f,\n}\nsolver = cad.nlpsol(\n\"Solver\",\n\"ipopt\",\nqp,\n)\nif self.last_x_init is not None:\nx_init = self.last_x_init\nx_init[0] = bias_calc\nelse:\nx_init = cad.vertcat(*x_init)\nsol = solver(\nx0=x_init,\n)\nfitted_bias = float(sol[\"x\"][0].full()[0])\nfitted_phase = phase\nfitted_w_0 = w_0\nfitted_params = np.zeros((self._num_functions, 2))\nfitted_params[:, 0] = np.array(\nsol[\"x\"][1 : 1 + self._num_functions].full()\n).reshape((self._num_functions,))\nfitted_params[:, 1] = np.array(\nsol[\"x\"][1 + self._num_functions :].full()\n).reshape((self._num_functions,))\nself.last_x_init = sol[\"x\"].full().flatten()\nreturn fitted_params, fitted_w_0, fitted_bias, fitted_phase\n</code></pre>"},{"location":"source/models/#models.oven_estimator.OvenEstimator.__init__","title":"<code>__init__(self, dt, num_functions)</code>  <code>special</code>","text":"Source code in <code>models/oven_estimator.py</code> <pre><code>def __init__(self, dt: float, num_functions: int) -&gt; None:\nself._dt = dt\nself._num_functions = num_functions\nself._model = FourierSeriesModel(self._num_functions)\nself.last_x_init = None\n</code></pre>"},{"location":"source/models/#models.oven_estimator.OvenEstimator.fit_params","title":"<code>fit_params(self, outer_measurements)</code>","text":"Source code in <code>models/oven_estimator.py</code> <pre><code>def fit_params(\nself, outer_measurements: List[float]\n) -&gt; Tuple[np.ndarray, float, float, float]:\nbias_calc, w_calc = self.get_frequency(outer_measurements)\nx_init = []\nw = []\nbias = cad.SX.sym(\"bias\", 1)\nw.append(bias)\nx_init.append(bias_calc)\nphase = 0\nw_0 = w_calc\namplitudes = cad.SX.sym(\"amplitudes\", (self._num_functions, 2))\nw += cad.horzsplit(amplitudes)\nx_init.append([0.010, 0.01] * self._num_functions)\nf = 0\nfor i in range(len(outer_measurements)):\nf += (\n1.001**i\n* (\nouter_measurements[i]\n- self._model.casadi_fun(i * self._dt, amplitudes, w_0, bias, phase)\n)\n** 2.0\n)\nqp = {\n\"x\": cad.vertcat(*w),\n\"f\": f,\n}\nsolver = cad.nlpsol(\n\"Solver\",\n\"ipopt\",\nqp,\n)\nif self.last_x_init is not None:\nx_init = self.last_x_init\nx_init[0] = bias_calc\nelse:\nx_init = cad.vertcat(*x_init)\nsol = solver(\nx0=x_init,\n)\nfitted_bias = float(sol[\"x\"][0].full()[0])\nfitted_phase = phase\nfitted_w_0 = w_0\nfitted_params = np.zeros((self._num_functions, 2))\nfitted_params[:, 0] = np.array(\nsol[\"x\"][1 : 1 + self._num_functions].full()\n).reshape((self._num_functions,))\nfitted_params[:, 1] = np.array(\nsol[\"x\"][1 + self._num_functions :].full()\n).reshape((self._num_functions,))\nself.last_x_init = sol[\"x\"].full().flatten()\nreturn fitted_params, fitted_w_0, fitted_bias, fitted_phase\n</code></pre>"},{"location":"source/models/#models.oven_estimator.OvenEstimator.get_frequency","title":"<code>get_frequency(self, measurements)</code>","text":"Source code in <code>models/oven_estimator.py</code> <pre><code>def get_frequency(self, measurements):\n\"\"\" \"\"\"\nmeas = np.array(measurements)\nbias = np.mean(measurements)\nmeas[meas &lt; bias] = -1\nmeas[meas &gt;= bias] = 1\ndiff = np.abs(np.diff(meas))\nindex_changes = np.where(diff &gt; 1)[0]\nprint(\"changes_before\", index_changes)\n# add logic for filtering\nif index_changes.shape[0] &gt; 1:\nlast_index = index_changes[0]\nfiltered_changes = [last_index]\nfor i in range(1, index_changes.shape[0]):\ncurr_diff = index_changes[i] - last_index\nif curr_diff &gt; 15:\nfiltered_changes.append(index_changes[i])\nlast_index = index_changes[i]\nindex_changes = np.array(filtered_changes)\nprint(\"changes_after\", index_changes)\nsteps = 0\nif index_changes.shape[0] == 1:\nsteps = np.max([index_changes * 2.0, meas.shape[0]])\nelif index_changes.shape[0] == 2:\nsteps = np.max([index_changes[1] - index_changes[0], meas.shape[0]])\nelse:\ndiff_indices = np.diff(index_changes)\nphase_1 = diff_indices[::2]\nphase_2 = diff_indices[1::2]\nsteps = np.mean(phase_1) + np.mean(phase_2)\nif steps == 0:\nw = 0.0\nelse:\nw = 2 * np.pi / (steps * self._dt)\nreturn bias, w\n</code></pre>"},{"location":"source/models/#models.oven_model","title":"<code>oven_model</code>","text":""},{"location":"source/models/#models.oven_model.OvenModel","title":"<code> OvenModel        </code>","text":"Source code in <code>models/oven_model.py</code> <pre><code>class OvenModel:\ndef __init__(self) -&gt; None:\npass\ndef two_point_controller(self, temp, heating, upper_temp, lower_temp):\nif heating and temp &gt;= upper_temp:\nheating = False\nif not heating and temp &lt;= lower_temp:\nheating = True\nreturn heating\ndef ode(self, x, heating, ambient_constant, heat_constant, temp_ambient, damping):\n\"\"\"\n        state = T, heating\n        heating = if heating &amp; T&gt; upper -&gt; heating=False\n        dT = k*(T_a - T) + u\n        u =\n        \"\"\"\ndx = np.array(\n[\nx[1],\nambient_constant * (temp_ambient - x[0])\n+ heating * heat_constant\n- damping * x[1],\n]\n)\nreturn dx\ndef next_temp(\nself,\nx,\nheating,\nupper_temp,\nlower_temp,\nambient_constant,\nheat_constant,\ntemp_ambient,\ndamping,\ndt,\n):\nheating = self.two_point_controller(x[0], heating, upper_temp, lower_temp)\nreturn (\nx\n+ self.ode(\nx, heating, ambient_constant, heat_constant, temp_ambient, damping\n)\n* dt,\nheating,\n)\n</code></pre>"},{"location":"source/models/#models.oven_model.OvenModel.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"Source code in <code>models/oven_model.py</code> <pre><code>def __init__(self) -&gt; None:\npass\n</code></pre>"},{"location":"source/models/#models.oven_model.OvenModel.next_temp","title":"<code>next_temp(self, x, heating, upper_temp, lower_temp, ambient_constant, heat_constant, temp_ambient, damping, dt)</code>","text":"Source code in <code>models/oven_model.py</code> <pre><code>def next_temp(\nself,\nx,\nheating,\nupper_temp,\nlower_temp,\nambient_constant,\nheat_constant,\ntemp_ambient,\ndamping,\ndt,\n):\nheating = self.two_point_controller(x[0], heating, upper_temp, lower_temp)\nreturn (\nx\n+ self.ode(\nx, heating, ambient_constant, heat_constant, temp_ambient, damping\n)\n* dt,\nheating,\n)\n</code></pre>"},{"location":"source/models/#models.oven_model.OvenModel.ode","title":"<code>ode(self, x, heating, ambient_constant, heat_constant, temp_ambient, damping)</code>","text":"<p>state = T, heating heating = if heating &amp; T&gt; upper -&gt; heating=False dT = k*(T_a - T) + u u =</p> Source code in <code>models/oven_model.py</code> <pre><code>def ode(self, x, heating, ambient_constant, heat_constant, temp_ambient, damping):\n\"\"\"\n    state = T, heating\n    heating = if heating &amp; T&gt; upper -&gt; heating=False\n    dT = k*(T_a - T) + u\n    u =\n    \"\"\"\ndx = np.array(\n[\nx[1],\nambient_constant * (temp_ambient - x[0])\n+ heating * heat_constant\n- damping * x[1],\n]\n)\nreturn dx\n</code></pre>"},{"location":"source/models/#models.oven_model.OvenModel.two_point_controller","title":"<code>two_point_controller(self, temp, heating, upper_temp, lower_temp)</code>","text":"Source code in <code>models/oven_model.py</code> <pre><code>def two_point_controller(self, temp, heating, upper_temp, lower_temp):\nif heating and temp &gt;= upper_temp:\nheating = False\nif not heating and temp &lt;= lower_temp:\nheating = True\nreturn heating\n</code></pre>"},{"location":"source/models/#models.predictor","title":"<code>predictor</code>","text":""},{"location":"source/models/#models.predictor.PredictionInputData","title":"<code> PredictionInputData        </code>","text":"<p>Data Container for Prediction input data.</p> Source code in <code>models/predictor.py</code> <pre><code>class PredictionInputData:\n\"\"\"Data Container for Prediction input data.\"\"\"\ndef __init__(\nself,\nouter_measurements: List[float],\ninner_measurements: List[float],\nstart_time: int,\ncore_end_temp: float,\n) -&gt; None:\n\"\"\"Initialize the container.\n        Args:\n            outer_measurements (List[float]): Oven measurements\n            inner_measurements (List[float]): Core temperature measurements.\n            start_time (int): timestamp of the first measurement.\n            core_end_temp (float): Core temperature which should be reached at the end.\n        \"\"\"\nself.outer_measurements = outer_measurements\nself.inner_measurements = inner_measurements\nself.start_time = start_time\nself.core_end_temp = core_end_temp\n</code></pre>"},{"location":"source/models/#models.predictor.PredictionInputData.__init__","title":"<code>__init__(self, outer_measurements, inner_measurements, start_time, core_end_temp)</code>  <code>special</code>","text":"<p>Initialize the container.</p> <p>Parameters:</p> Name Type Description Default <code>outer_measurements</code> <code>List[float]</code> <p>Oven measurements</p> required <code>inner_measurements</code> <code>List[float]</code> <p>Core temperature measurements.</p> required <code>start_time</code> <code>int</code> <p>timestamp of the first measurement.</p> required <code>core_end_temp</code> <code>float</code> <p>Core temperature which should be reached at the end.</p> required Source code in <code>models/predictor.py</code> <pre><code>def __init__(\nself,\nouter_measurements: List[float],\ninner_measurements: List[float],\nstart_time: int,\ncore_end_temp: float,\n) -&gt; None:\n\"\"\"Initialize the container.\n    Args:\n        outer_measurements (List[float]): Oven measurements\n        inner_measurements (List[float]): Core temperature measurements.\n        start_time (int): timestamp of the first measurement.\n        core_end_temp (float): Core temperature which should be reached at the end.\n    \"\"\"\nself.outer_measurements = outer_measurements\nself.inner_measurements = inner_measurements\nself.start_time = start_time\nself.core_end_temp = core_end_temp\n</code></pre>"},{"location":"source/models/#models.predictor.PredictionResult","title":"<code> PredictionResult        </code>","text":"<p>Data Container for Prediction Results.</p> Source code in <code>models/predictor.py</code> <pre><code>class PredictionResult:\n\"\"\"Data Container for Prediction Results.\"\"\"\ndef __init__(\nself,\ntimestamps_fit: List[int],\noven_temp_fit: List[float],\nmeat_state_fit: List[List[float]],\ntimestamps_prediction: List[int],\noven_temp_prediction: List[float],\nmeat_state_prediction: List[List[float]],\ntimestamp_end: int,\n) -&gt; None:\n\"\"\"Initialize the input data.\n        Args:\n            timestamps_fit (List[int]): Timestamps of the fit in ns since epoch.\n            oven_temp_fit (List[float]): Temperature of the oven at the fit.\n            meat_state_fit (List[List[float]]):\n                Temperature of all meat states at the fit.\n            timestamps_prediction (List[int]):\n                Timestamps of the prediction in ns since epoch.\n            oven_temp_prediction (List[float]):\n                Temperature of the oven at the prediction.\n            meat_state_prediction (List[List[float]]):\n                Temperature of the meat states at the prediction.\n            timestamp_end (int): Timestamp when the core end temperature is reached.\n        \"\"\"\nself.timestamps_fit = timestamps_fit\nself.oven_temp_fit = oven_temp_fit\nself.meat_state_fit = meat_state_fit\nself.timestamps_prediction = timestamps_prediction\nself.oven_temp_prediction = oven_temp_prediction\nself.meat_state_prediction = meat_state_prediction\nself.timestamp_end = timestamp_end\ndef to_list(self) -&gt; List[Union[List[int], List[float], List[List[float]], int]]:\n\"\"\"Return as List.\n        Returns:\n            List[Union[List[int], List[float], List[List[float]], int]]:\n                List containing all data.\n        \"\"\"\nreturn [\nself.timestamps_fit,\nself.oven_temp_fit,\nself.meat_state_fit,\nself.timestamps_prediction,\nself.oven_temp_prediction,\nself.meat_state_prediction,\nself.timestamp_end,\n]\n</code></pre>"},{"location":"source/models/#models.predictor.PredictionResult.__init__","title":"<code>__init__(self, timestamps_fit, oven_temp_fit, meat_state_fit, timestamps_prediction, oven_temp_prediction, meat_state_prediction, timestamp_end)</code>  <code>special</code>","text":"<p>Initialize the input data.</p> <p>Parameters:</p> Name Type Description Default <code>timestamps_fit</code> <code>List[int]</code> <p>Timestamps of the fit in ns since epoch.</p> required <code>oven_temp_fit</code> <code>List[float]</code> <p>Temperature of the oven at the fit.</p> required <code>meat_state_fit</code> <code>List[List[float]]</code> <p>Temperature of all meat states at the fit.</p> required <code>timestamps_prediction</code> <code>List[int]</code> <p>Timestamps of the prediction in ns since epoch.</p> required <code>oven_temp_prediction</code> <code>List[float]</code> <p>Temperature of the oven at the prediction.</p> required <code>meat_state_prediction</code> <code>List[List[float]]</code> <p>Temperature of the meat states at the prediction.</p> required <code>timestamp_end</code> <code>int</code> <p>Timestamp when the core end temperature is reached.</p> required Source code in <code>models/predictor.py</code> <pre><code>def __init__(\nself,\ntimestamps_fit: List[int],\noven_temp_fit: List[float],\nmeat_state_fit: List[List[float]],\ntimestamps_prediction: List[int],\noven_temp_prediction: List[float],\nmeat_state_prediction: List[List[float]],\ntimestamp_end: int,\n) -&gt; None:\n\"\"\"Initialize the input data.\n    Args:\n        timestamps_fit (List[int]): Timestamps of the fit in ns since epoch.\n        oven_temp_fit (List[float]): Temperature of the oven at the fit.\n        meat_state_fit (List[List[float]]):\n            Temperature of all meat states at the fit.\n        timestamps_prediction (List[int]):\n            Timestamps of the prediction in ns since epoch.\n        oven_temp_prediction (List[float]):\n            Temperature of the oven at the prediction.\n        meat_state_prediction (List[List[float]]):\n            Temperature of the meat states at the prediction.\n        timestamp_end (int): Timestamp when the core end temperature is reached.\n    \"\"\"\nself.timestamps_fit = timestamps_fit\nself.oven_temp_fit = oven_temp_fit\nself.meat_state_fit = meat_state_fit\nself.timestamps_prediction = timestamps_prediction\nself.oven_temp_prediction = oven_temp_prediction\nself.meat_state_prediction = meat_state_prediction\nself.timestamp_end = timestamp_end\n</code></pre>"},{"location":"source/models/#models.predictor.PredictionResult.to_list","title":"<code>to_list(self)</code>","text":"<p>Return as List.</p> <p>Returns:</p> Type Description <code>List[Union[List[int], List[float], List[List[float]], int]]</code> <p>List containing all data.</p> Source code in <code>models/predictor.py</code> <pre><code>def to_list(self) -&gt; List[Union[List[int], List[float], List[List[float]], int]]:\n\"\"\"Return as List.\n    Returns:\n        List[Union[List[int], List[float], List[List[float]], int]]:\n            List containing all data.\n    \"\"\"\nreturn [\nself.timestamps_fit,\nself.oven_temp_fit,\nself.meat_state_fit,\nself.timestamps_prediction,\nself.oven_temp_prediction,\nself.meat_state_prediction,\nself.timestamp_end,\n]\n</code></pre>"},{"location":"source/models/#models.predictor.Predictor","title":"<code> Predictor        </code>","text":"<p>Predicts the time until the meat is ready.</p> <p>The measurement data is fit to a model which is used to predict the remaining time until a specific core temperature is reached.</p> Source code in <code>models/predictor.py</code> <pre><code>class Predictor:\n\"\"\"Predicts the time until the meat is ready.\n    The measurement data is fit to a model which is used to predict\n    the remaining time until a specific core temperature is reached.\n    \"\"\"\ndef __init__(self, dt: float, oven_num_func: int, meat_num_func: int) -&gt; None:\n\"\"\"Initialize the predictor.\n        Args:\n            dt (float): timedelta between two measurements in seconds.\n            oven_num_func (int): Used number of functions for the oven model.\n            meat_num_func (int): used number of functions for the meat model.\n        \"\"\"\nself._oven_est = OvenEstimator(dt, oven_num_func)\nself._meat_est = MeatEstimator(dt, meat_num_func)\nself._dt = dt\nself.process: Optional[Process] = None\nself.result: Optional[PredictionResult] = None\nself.input_q: Queue[PredictionInputData] = Queue(maxsize=1)\nself.output_q: Queue[PredictionResult] = Queue(maxsize=1)\nself._is_running = False\ndef fit(\nself, outer_measurement: List[float], inner_measurement: List[float]\n) -&gt; Tuple[Tuple[np.ndarray, float, float, float], Tuple[float, np.ndarray], float]:\n\"\"\"Fit parameters to measurements.\n        Args:\n            outer_measurement (List[float]): Measurement of outer temperature.\n            inner_measurement (List[float]): Measurement of inner/core temperature.\n        Returns:\n            Tuple[Tuple[np.ndarray, float, float, float], Tuple[float, np.ndarray],\n                float]: oven_parameter, meat_parameter, first_timestamp\n        \"\"\"\nself._oven_params = self._oven_est.fit_params(outer_measurement)\nself._meat_params = self._meat_est.fit_params(\ninner_measurement, outer_measurement\n)\nself._t0 = len(outer_measurement) * self._dt\nreturn self._oven_params, self._meat_params, self._t0\ndef predict(\nself, ref_temp: float, t_0: float, max_dur: float = 8.0 * 60 * 60\n) -&gt; Tuple[List[float], List[List[float]], float]:\n\"\"\"Predict temperature until a specific core temperature is reached.\n        Args:\n            ref_temp (float): core temperature to reach.\n            t_0 (float): first timestamp\n            max_dur (float, optional): maximum time to look into the future\n                in seconds. Defaults to 8*60*60.\n        Returns:\n            Tuple[List[float], List[List[float]], float]:\n                oven_temperature, meat_state, end_timestamp\n        \"\"\"\nmeat_x_0 = self._meat_params[1][-1, :]\noven_temp = [self._oven_est._model.func(t_0, *self._oven_params)]\nmeat_state = [meat_x_0.tolist()]\nfor i in range(int(max_dur / self._dt)):\nmeat_state.append(\nself._meat_est._model.next_state(\nmeat_state[-1], oven_temp[-1], self._meat_params[0], self._dt\n).tolist()\n)\noven_temp.append(\nself._oven_est._model.func(t_0 + (i + 1) * self._dt, *self._oven_params)\n)\nif meat_state[-1][-1] &gt;= ref_temp:\nbreak\nreturn oven_temp, meat_state, i * self._dt + t_0\ndef run_parallel(self, input_data: PredictionInputData) -&gt; None:\n\"\"\"run the fitting and prediction in a parallel fashion.\n        Args:\n            input_data (PredictionInputData): Measurements for fitting.\n        \"\"\"\nself.save_result()\nif self.is_running():\nreturn\nself.input_q.put(input_data)\nself._is_running = True\nif self.process is None or not self.process.is_alive():\nself.process = Process(\ntarget=self.generate_result,\ndaemon=True,\n)\nself.process.start()\nreturn\ndef is_running(self) -&gt; bool:\n\"\"\"Check if prediction is running.\n        Returns:\n            bool: true if a prediction is running.\n        \"\"\"\nself.save_result()\nif self.process is None:\nself._is_running = False\nreturn False\nif not self.process.is_alive():\nself.process.close()\nself.process = None\nself._is_running = False\nreturn False\nreturn self._is_running\ndef maybe_get_result(\nself,\n) -&gt; Optional[PredictionResult]:\n\"\"\"Get a result if available else return None.\n        Returns:\n            Optional[PredictionResult]: Last prediction result.\n        \"\"\"\nself.save_result()\nif self.is_running():\nreturn None\nif self.result is not None:\nresult_return = copy.deepcopy(self.result)\nself.result = None\nreturn result_return\nreturn None\ndef save_result(self) -&gt; None:\n\"\"\"Save result from second process.\"\"\"\nif not self.output_q.empty():\nself.result = self.output_q.get()\nself._is_running = False\ndef generate_result(self) -&gt; None:\n\"\"\"Generate a new result.\n        This function runs in a second process.\n        \"\"\"\ntry:\nwhile True:\ndata = self.input_q.get()\nstart_time = data.start_time\noven_params, meat_params, t_0 = self.fit(\ndata.outer_measurements, data.inner_measurements\n)\noven_temp, meat_state, duration_to_end = self.predict(\ndata.core_end_temp, t_0\n)\nt_fit = start_time + np.array(\nnp.arange(len(meat_params[1])), dtype=int\n) * int(self._dt * 1e9)\nt_pred = t_fit[-1] + np.array(\nnp.arange(len(oven_temp)), dtype=int\n) * int(self._dt * 1e9)\nt_oven = (\nnp.array(np.arange(meat_params[1].shape[0]), dtype=float) * self._dt\n)\nt_end = start_time + int(duration_to_end * 1e9)\noven_fit = []\nfor i in range(t_oven.shape[0]):\noven_fit.append(self._oven_est._model.func(t_oven[i], *oven_params))\nresult = [\nt_fit.tolist(),\noven_fit,\nmeat_params[1].tolist(),\nt_pred.tolist(),\noven_temp,\nmeat_state,\nt_end,\n]\nself.output_q.put(PredictionResult(*result))\nexcept BaseException as err:\nprint(f\"Unexpected {err=}, {type(err)=}\")\ntraceback.print_exc()\n</code></pre>"},{"location":"source/models/#models.predictor.Predictor.__init__","title":"<code>__init__(self, dt, oven_num_func, meat_num_func)</code>  <code>special</code>","text":"<p>Initialize the predictor.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>timedelta between two measurements in seconds.</p> required <code>oven_num_func</code> <code>int</code> <p>Used number of functions for the oven model.</p> required <code>meat_num_func</code> <code>int</code> <p>used number of functions for the meat model.</p> required Source code in <code>models/predictor.py</code> <pre><code>def __init__(self, dt: float, oven_num_func: int, meat_num_func: int) -&gt; None:\n\"\"\"Initialize the predictor.\n    Args:\n        dt (float): timedelta between two measurements in seconds.\n        oven_num_func (int): Used number of functions for the oven model.\n        meat_num_func (int): used number of functions for the meat model.\n    \"\"\"\nself._oven_est = OvenEstimator(dt, oven_num_func)\nself._meat_est = MeatEstimator(dt, meat_num_func)\nself._dt = dt\nself.process: Optional[Process] = None\nself.result: Optional[PredictionResult] = None\nself.input_q: Queue[PredictionInputData] = Queue(maxsize=1)\nself.output_q: Queue[PredictionResult] = Queue(maxsize=1)\nself._is_running = False\n</code></pre>"},{"location":"source/models/#models.predictor.Predictor.fit","title":"<code>fit(self, outer_measurement, inner_measurement)</code>","text":"<p>Fit parameters to measurements.</p> <p>Parameters:</p> Name Type Description Default <code>outer_measurement</code> <code>List[float]</code> <p>Measurement of outer temperature.</p> required <code>inner_measurement</code> <code>List[float]</code> <p>Measurement of inner/core temperature.</p> required <p>Returns:</p> Type Description <code>Tuple[Tuple[np.ndarray, float, float, float], Tuple[float, np.ndarray],     float]</code> <p>oven_parameter, meat_parameter, first_timestamp</p> Source code in <code>models/predictor.py</code> <pre><code>def fit(\nself, outer_measurement: List[float], inner_measurement: List[float]\n) -&gt; Tuple[Tuple[np.ndarray, float, float, float], Tuple[float, np.ndarray], float]:\n\"\"\"Fit parameters to measurements.\n    Args:\n        outer_measurement (List[float]): Measurement of outer temperature.\n        inner_measurement (List[float]): Measurement of inner/core temperature.\n    Returns:\n        Tuple[Tuple[np.ndarray, float, float, float], Tuple[float, np.ndarray],\n            float]: oven_parameter, meat_parameter, first_timestamp\n    \"\"\"\nself._oven_params = self._oven_est.fit_params(outer_measurement)\nself._meat_params = self._meat_est.fit_params(\ninner_measurement, outer_measurement\n)\nself._t0 = len(outer_measurement) * self._dt\nreturn self._oven_params, self._meat_params, self._t0\n</code></pre>"},{"location":"source/models/#models.predictor.Predictor.generate_result","title":"<code>generate_result(self)</code>","text":"<p>Generate a new result.</p> <p>This function runs in a second process.</p> Source code in <code>models/predictor.py</code> <pre><code>def generate_result(self) -&gt; None:\n\"\"\"Generate a new result.\n    This function runs in a second process.\n    \"\"\"\ntry:\nwhile True:\ndata = self.input_q.get()\nstart_time = data.start_time\noven_params, meat_params, t_0 = self.fit(\ndata.outer_measurements, data.inner_measurements\n)\noven_temp, meat_state, duration_to_end = self.predict(\ndata.core_end_temp, t_0\n)\nt_fit = start_time + np.array(\nnp.arange(len(meat_params[1])), dtype=int\n) * int(self._dt * 1e9)\nt_pred = t_fit[-1] + np.array(\nnp.arange(len(oven_temp)), dtype=int\n) * int(self._dt * 1e9)\nt_oven = (\nnp.array(np.arange(meat_params[1].shape[0]), dtype=float) * self._dt\n)\nt_end = start_time + int(duration_to_end * 1e9)\noven_fit = []\nfor i in range(t_oven.shape[0]):\noven_fit.append(self._oven_est._model.func(t_oven[i], *oven_params))\nresult = [\nt_fit.tolist(),\noven_fit,\nmeat_params[1].tolist(),\nt_pred.tolist(),\noven_temp,\nmeat_state,\nt_end,\n]\nself.output_q.put(PredictionResult(*result))\nexcept BaseException as err:\nprint(f\"Unexpected {err=}, {type(err)=}\")\ntraceback.print_exc()\n</code></pre>"},{"location":"source/models/#models.predictor.Predictor.is_running","title":"<code>is_running(self)</code>","text":"<p>Check if prediction is running.</p> <p>Returns:</p> Type Description <code>bool</code> <p>true if a prediction is running.</p> Source code in <code>models/predictor.py</code> <pre><code>def is_running(self) -&gt; bool:\n\"\"\"Check if prediction is running.\n    Returns:\n        bool: true if a prediction is running.\n    \"\"\"\nself.save_result()\nif self.process is None:\nself._is_running = False\nreturn False\nif not self.process.is_alive():\nself.process.close()\nself.process = None\nself._is_running = False\nreturn False\nreturn self._is_running\n</code></pre>"},{"location":"source/models/#models.predictor.Predictor.maybe_get_result","title":"<code>maybe_get_result(self)</code>","text":"<p>Get a result if available else return None.</p> <p>Returns:</p> Type Description <code>Optional[PredictionResult]</code> <p>Last prediction result.</p> Source code in <code>models/predictor.py</code> <pre><code>def maybe_get_result(\nself,\n) -&gt; Optional[PredictionResult]:\n\"\"\"Get a result if available else return None.\n    Returns:\n        Optional[PredictionResult]: Last prediction result.\n    \"\"\"\nself.save_result()\nif self.is_running():\nreturn None\nif self.result is not None:\nresult_return = copy.deepcopy(self.result)\nself.result = None\nreturn result_return\nreturn None\n</code></pre>"},{"location":"source/models/#models.predictor.Predictor.predict","title":"<code>predict(self, ref_temp, t_0, max_dur=28800.0)</code>","text":"<p>Predict temperature until a specific core temperature is reached.</p> <p>Parameters:</p> Name Type Description Default <code>ref_temp</code> <code>float</code> <p>core temperature to reach.</p> required <code>t_0</code> <code>float</code> <p>first timestamp</p> required <code>max_dur</code> <code>float</code> <p>maximum time to look into the future in seconds. Defaults to 86060.</p> <code>28800.0</code> <p>Returns:</p> Type Description <code>Tuple[List[float], List[List[float]], float]</code> <p>oven_temperature, meat_state, end_timestamp</p> Source code in <code>models/predictor.py</code> <pre><code>def predict(\nself, ref_temp: float, t_0: float, max_dur: float = 8.0 * 60 * 60\n) -&gt; Tuple[List[float], List[List[float]], float]:\n\"\"\"Predict temperature until a specific core temperature is reached.\n    Args:\n        ref_temp (float): core temperature to reach.\n        t_0 (float): first timestamp\n        max_dur (float, optional): maximum time to look into the future\n            in seconds. Defaults to 8*60*60.\n    Returns:\n        Tuple[List[float], List[List[float]], float]:\n            oven_temperature, meat_state, end_timestamp\n    \"\"\"\nmeat_x_0 = self._meat_params[1][-1, :]\noven_temp = [self._oven_est._model.func(t_0, *self._oven_params)]\nmeat_state = [meat_x_0.tolist()]\nfor i in range(int(max_dur / self._dt)):\nmeat_state.append(\nself._meat_est._model.next_state(\nmeat_state[-1], oven_temp[-1], self._meat_params[0], self._dt\n).tolist()\n)\noven_temp.append(\nself._oven_est._model.func(t_0 + (i + 1) * self._dt, *self._oven_params)\n)\nif meat_state[-1][-1] &gt;= ref_temp:\nbreak\nreturn oven_temp, meat_state, i * self._dt + t_0\n</code></pre>"},{"location":"source/models/#models.predictor.Predictor.run_parallel","title":"<code>run_parallel(self, input_data)</code>","text":"<p>run the fitting and prediction in a parallel fashion.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>PredictionInputData</code> <p>Measurements for fitting.</p> required Source code in <code>models/predictor.py</code> <pre><code>def run_parallel(self, input_data: PredictionInputData) -&gt; None:\n\"\"\"run the fitting and prediction in a parallel fashion.\n    Args:\n        input_data (PredictionInputData): Measurements for fitting.\n    \"\"\"\nself.save_result()\nif self.is_running():\nreturn\nself.input_q.put(input_data)\nself._is_running = True\nif self.process is None or not self.process.is_alive():\nself.process = Process(\ntarget=self.generate_result,\ndaemon=True,\n)\nself.process.start()\nreturn\n</code></pre>"},{"location":"source/models/#models.predictor.Predictor.save_result","title":"<code>save_result(self)</code>","text":"<p>Save result from second process.</p> Source code in <code>models/predictor.py</code> <pre><code>def save_result(self) -&gt; None:\n\"\"\"Save result from second process.\"\"\"\nif not self.output_q.empty():\nself.result = self.output_q.get()\nself._is_running = False\n</code></pre>"},{"location":"source/simulator/","title":"Simulator","text":"<p>Simulator application.</p> <p>Implementation of a simulator for the measurements of a measurement device. For testing purpose only.</p>"},{"location":"source/simulator/#simulator.main","title":"<code>main</code>","text":"<p>Main application of the Simulator.</p> <p>The simulator simulates a measurement device and sends the values via htttp post to the server.</p>"},{"location":"source/simulator/#simulator.main.main","title":"<code>main()</code>","text":"<p>Run the simulator.</p> Source code in <code>simulator/main.py</code> <pre><code>def main():\n\"\"\"Run the simulator.\"\"\"\nport = 5000\nhost = \"192.168.2.106\"\nurl = \"http://\" + host + \":\" + str(port) + \"/input\"\nvalue_2 = 15.1\nstart_time = round(time() * 1e9)\noven_model = OvenModel()\nheating = True\nupper_temp = 55.0\nlower_temp = 45.0\nambient_constant = 0.00001\nheat_constant = 0.0004\ntemp_ambient = 20.0\ndamping = 0.010\noven_state = np.array([45.0, 0.0])\nmeat_model = MeatModel()\nmeat_state = np.linspace(10.0, 19.0, 10)[::-1]\nfor i in range(100000):\noven_state, heating = oven_model.next_temp(\noven_state,\nheating,\nupper_temp,\nlower_temp,\nambient_constant,\nheat_constant,\ntemp_ambient,\ndamping,\n1.0,\n)\nlast_timestamp_oven = start_time\nlast_timestamp_meat = start_time\nfor i in range(1000000):\ncurr_time_mu_1 = round(time() * 1e9)\noven_state, heating = oven_model.next_temp(\noven_state,\nheating,\nupper_temp,\nlower_temp,\nambient_constant,\nheat_constant,\ntemp_ambient,\ndamping,\n(curr_time_mu_1 - last_timestamp_oven) * 1e-9,\n)\nvalue_1 = oven_state[0] + np.random.normal() * 0.01\ncurr_time_mu_2 = round(time() * 1e9)\nnext_meat_state = meat_model.next_state(\nmeat_state, value_1, 7.2, (curr_time_mu_2 - last_timestamp_meat) * 1e-9\n)\nvalue_2 = next_meat_state[-1] + np.random.normal() * 0.01\nsend_string = (\nf\"Measurement,device=TempSens,Sensor=1 value={value_1} {curr_time_mu_1}\\n\"\nf\"Measurement,device=TempSens,Sensor=2 value={value_2} {curr_time_mu_2}\\n\"\n)\nx = requests.post(url, send_string)\nlast_timestamp_oven = curr_time_mu_1\nlast_timestamp_meat = curr_time_mu_2\nmeat_state = next_meat_state\nprint(x.text)\nsleep(0.99)\n</code></pre>"},{"location":"source/temperatur_server/","title":"Temperature Server","text":"<p>Server implementation.</p> <p>This module implements the web server application.</p>"},{"location":"source/temperatur_server/#temperatur_server.api","title":"<code>api</code>  <code>special</code>","text":"<p>Api implementation.</p> <p>This module implements different SocketIO apis.</p>"},{"location":"source/temperatur_server/#temperatur_server.api.api_manager","title":"<code>api_manager</code>","text":"<p>Implementation to manage different apis.</p>"},{"location":"source/temperatur_server/#temperatur_server.api.api_manager.ApiManager","title":"<code> ApiManager        </code>","text":"<p>Manages the usage of different SocketIO apis.</p> Source code in <code>temperatur_server/api/api_manager.py</code> <pre><code>class ApiManager:\n\"\"\"Manages the usage of different SocketIO apis.\"\"\"\ndef __init__(\nself, state: ServerState, database: MeasurementDB, socket_io: SocketIO\n) -&gt; None:\n\"\"\"Initialize the Manager for the different apis\n        Args:\n            state (_type_): _description_\n            database (_type_): _description_\n            socket_io (_type_): _description_\n        \"\"\"\nself.state = state\nself.socket_io = socket_io\nself.api_list = [JavaScriptApi(state, database, \"/js\")]\nself.register_apis()\ndef register_apis(self) -&gt; None:\n\"\"\"Register all apis to the socket io server.\"\"\"\nfor api in self.api_list:\nself.socket_io.on_namespace(api)\ndef emit_all(\nself,\nevent,\ndata=None,\nroom=None,\ninclude_self=True,\nnamespace=None,\ncallback=None,\n):\n\"\"\"Emit a message to all apis.\n            All arguments are forwarded to each api.\n        Args:\n            event (any): event name\n            data (any, optional): data. Defaults to None.\n            room (any, optional): room. Defaults to None.\n            include_self (bool, optional): include_self. Defaults to True.\n            namespace (any, optional): namespace. Defaults to None.\n            callback (any, optional): callback. Defaults to None.\n        \"\"\"\nfor api in self.api_list:\napi.emit(event, data, room, include_self, namespace, callback)\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.api.api_manager.ApiManager.__init__","title":"<code>__init__(self, state, database, socket_io)</code>  <code>special</code>","text":"<p>Initialize the Manager for the different apis</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>_type_</code> <p>description</p> required <code>database</code> <code>_type_</code> <p>description</p> required <code>socket_io</code> <code>_type_</code> <p>description</p> required Source code in <code>temperatur_server/api/api_manager.py</code> <pre><code>def __init__(\nself, state: ServerState, database: MeasurementDB, socket_io: SocketIO\n) -&gt; None:\n\"\"\"Initialize the Manager for the different apis\n    Args:\n        state (_type_): _description_\n        database (_type_): _description_\n        socket_io (_type_): _description_\n    \"\"\"\nself.state = state\nself.socket_io = socket_io\nself.api_list = [JavaScriptApi(state, database, \"/js\")]\nself.register_apis()\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.api.api_manager.ApiManager.emit_all","title":"<code>emit_all(self, event, data=None, room=None, include_self=True, namespace=None, callback=None)</code>","text":"<p>Emit a message to all apis.</p> <pre><code>All arguments are forwarded to each api.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>any</code> <p>event name</p> required <code>data</code> <code>any</code> <p>data. Defaults to None.</p> <code>None</code> <code>room</code> <code>any</code> <p>room. Defaults to None.</p> <code>None</code> <code>include_self</code> <code>bool</code> <p>include_self. Defaults to True.</p> <code>True</code> <code>namespace</code> <code>any</code> <p>namespace. Defaults to None.</p> <code>None</code> <code>callback</code> <code>any</code> <p>callback. Defaults to None.</p> <code>None</code> Source code in <code>temperatur_server/api/api_manager.py</code> <pre><code>def emit_all(\nself,\nevent,\ndata=None,\nroom=None,\ninclude_self=True,\nnamespace=None,\ncallback=None,\n):\n\"\"\"Emit a message to all apis.\n        All arguments are forwarded to each api.\n    Args:\n        event (any): event name\n        data (any, optional): data. Defaults to None.\n        room (any, optional): room. Defaults to None.\n        include_self (bool, optional): include_self. Defaults to True.\n        namespace (any, optional): namespace. Defaults to None.\n        callback (any, optional): callback. Defaults to None.\n    \"\"\"\nfor api in self.api_list:\napi.emit(event, data, room, include_self, namespace, callback)\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.api.api_manager.ApiManager.register_apis","title":"<code>register_apis(self)</code>","text":"<p>Register all apis to the socket io server.</p> Source code in <code>temperatur_server/api/api_manager.py</code> <pre><code>def register_apis(self) -&gt; None:\n\"\"\"Register all apis to the socket io server.\"\"\"\nfor api in self.api_list:\nself.socket_io.on_namespace(api)\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.api.js_api","title":"<code>js_api</code>","text":"<p>Implementation for an api for JavaScript webpage.</p>"},{"location":"source/temperatur_server/#temperatur_server.api.js_api.JavaScriptApi","title":"<code> JavaScriptApi            (Namespace)         </code>","text":"<p>Api for the usage with java script.</p> <p>Inheritance of socketIO namespace</p> Source code in <code>temperatur_server/api/js_api.py</code> <pre><code>class JavaScriptApi(flask_socketio.Namespace):\n\"\"\"Api for the usage with java script.\n    Inheritance of socketIO namespace\n    \"\"\"\ndef __init__(\nself, server_state: ServerState, database: MeasurementDB, namespace: str = \"/js\"\n) -&gt; None:\n\"\"\"Initialize the Api\n        Args:\n            server_state (ServerState): Current State of the server\n            database (MeasurementDB): Database\n            namespace (str, optional): SocketIO namespace. Defaults to \"/js\".\n        \"\"\"\nsuper().__init__(namespace=namespace)\nself.server_state = server_state\nself.database = database\ndef on_getTimeSeries(self, date) -&gt; str:\n\"\"\"Get the data time series\n        Args:\n            date (_type_): _description_\n        Returns:\n            str: All relevant data\n        \"\"\"\nreturn_value = self.database.getBetweenTime(\nself.server_state.start_time - self.server_state.nano_seconds_before_start\n)\nreturn return_value\ndef on_getOvenRefTemp(self, date) -&gt; float:\n\"\"\"get the current oven reference temperature.\n        Args:\n            date (_type_): _description_\n        Returns:\n            float: the current oven ref temp\n        \"\"\"\nreturn self.server_state.oven_ref_temp\ndef on_getCoreRefTemp(self, date) -&gt; float:\n\"\"\"get the current core reference temperature.\n        Args:\n            date (_type_): unused\n        Returns:\n            float: core reference temperature.\n        \"\"\"\nreturn self.server_state.core_ref_temp\ndef on_newOvenRef(self, data: float) -&gt; None:\n\"\"\"set a new Oven Reference Temperature.\n        Args:\n            data (float): the new oven reference temperature.\n        \"\"\"\nself.server_state.oven_ref_temp = data\ndef on_newCoreRef(self, data: float) -&gt; None:\n\"\"\"Set a new core reference temperature.\n        Args:\n            data (float): the new core reference temperature\n        \"\"\"\nself.server_state.core_ref_temp = data\ndef on_newStartTime(self, data: int) -&gt; None:\n\"\"\"set a new start time.\n        Args:\n            data (int): new start time in nanoseconds since epoch.\n        \"\"\"\nself.server_state.start_time = int(data)\ndef on_getStartTime(self, data) -&gt; int:\n\"\"\"Get the current start time.\n        Args:\n            data (_type_): unused\n        Returns:\n            int: current start time in nanoseconds since epoch.\n        \"\"\"\nreturn self.server_state.start_time\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.api.js_api.JavaScriptApi.__init__","title":"<code>__init__(self, server_state, database, namespace='/js')</code>  <code>special</code>","text":"<p>Initialize the Api</p> <p>Parameters:</p> Name Type Description Default <code>server_state</code> <code>ServerState</code> <p>Current State of the server</p> required <code>database</code> <code>MeasurementDB</code> <p>Database</p> required <code>namespace</code> <code>str</code> <p>SocketIO namespace. Defaults to \"/js\".</p> <code>'/js'</code> Source code in <code>temperatur_server/api/js_api.py</code> <pre><code>def __init__(\nself, server_state: ServerState, database: MeasurementDB, namespace: str = \"/js\"\n) -&gt; None:\n\"\"\"Initialize the Api\n    Args:\n        server_state (ServerState): Current State of the server\n        database (MeasurementDB): Database\n        namespace (str, optional): SocketIO namespace. Defaults to \"/js\".\n    \"\"\"\nsuper().__init__(namespace=namespace)\nself.server_state = server_state\nself.database = database\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.api.js_api.JavaScriptApi.on_getCoreRefTemp","title":"<code>on_getCoreRefTemp(self, date)</code>","text":"<p>get the current core reference temperature.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>_type_</code> <p>unused</p> required <p>Returns:</p> Type Description <code>float</code> <p>core reference temperature.</p> Source code in <code>temperatur_server/api/js_api.py</code> <pre><code>def on_getCoreRefTemp(self, date) -&gt; float:\n\"\"\"get the current core reference temperature.\n    Args:\n        date (_type_): unused\n    Returns:\n        float: core reference temperature.\n    \"\"\"\nreturn self.server_state.core_ref_temp\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.api.js_api.JavaScriptApi.on_getOvenRefTemp","title":"<code>on_getOvenRefTemp(self, date)</code>","text":"<p>get the current oven reference temperature.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>_type_</code> <p>description</p> required <p>Returns:</p> Type Description <code>float</code> <p>the current oven ref temp</p> Source code in <code>temperatur_server/api/js_api.py</code> <pre><code>def on_getOvenRefTemp(self, date) -&gt; float:\n\"\"\"get the current oven reference temperature.\n    Args:\n        date (_type_): _description_\n    Returns:\n        float: the current oven ref temp\n    \"\"\"\nreturn self.server_state.oven_ref_temp\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.api.js_api.JavaScriptApi.on_getStartTime","title":"<code>on_getStartTime(self, data)</code>","text":"<p>Get the current start time.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>_type_</code> <p>unused</p> required <p>Returns:</p> Type Description <code>int</code> <p>current start time in nanoseconds since epoch.</p> Source code in <code>temperatur_server/api/js_api.py</code> <pre><code>def on_getStartTime(self, data) -&gt; int:\n\"\"\"Get the current start time.\n    Args:\n        data (_type_): unused\n    Returns:\n        int: current start time in nanoseconds since epoch.\n    \"\"\"\nreturn self.server_state.start_time\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.api.js_api.JavaScriptApi.on_getTimeSeries","title":"<code>on_getTimeSeries(self, date)</code>","text":"<p>Get the data time series</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>_type_</code> <p>description</p> required <p>Returns:</p> Type Description <code>str</code> <p>All relevant data</p> Source code in <code>temperatur_server/api/js_api.py</code> <pre><code>def on_getTimeSeries(self, date) -&gt; str:\n\"\"\"Get the data time series\n    Args:\n        date (_type_): _description_\n    Returns:\n        str: All relevant data\n    \"\"\"\nreturn_value = self.database.getBetweenTime(\nself.server_state.start_time - self.server_state.nano_seconds_before_start\n)\nreturn return_value\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.api.js_api.JavaScriptApi.on_newCoreRef","title":"<code>on_newCoreRef(self, data)</code>","text":"<p>Set a new core reference temperature.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>float</code> <p>the new core reference temperature</p> required Source code in <code>temperatur_server/api/js_api.py</code> <pre><code>def on_newCoreRef(self, data: float) -&gt; None:\n\"\"\"Set a new core reference temperature.\n    Args:\n        data (float): the new core reference temperature\n    \"\"\"\nself.server_state.core_ref_temp = data\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.api.js_api.JavaScriptApi.on_newOvenRef","title":"<code>on_newOvenRef(self, data)</code>","text":"<p>set a new Oven Reference Temperature.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>float</code> <p>the new oven reference temperature.</p> required Source code in <code>temperatur_server/api/js_api.py</code> <pre><code>def on_newOvenRef(self, data: float) -&gt; None:\n\"\"\"set a new Oven Reference Temperature.\n    Args:\n        data (float): the new oven reference temperature.\n    \"\"\"\nself.server_state.oven_ref_temp = data\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.api.js_api.JavaScriptApi.on_newStartTime","title":"<code>on_newStartTime(self, data)</code>","text":"<p>set a new start time.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>int</code> <p>new start time in nanoseconds since epoch.</p> required Source code in <code>temperatur_server/api/js_api.py</code> <pre><code>def on_newStartTime(self, data: int) -&gt; None:\n\"\"\"set a new start time.\n    Args:\n        data (int): new start time in nanoseconds since epoch.\n    \"\"\"\nself.server_state.start_time = int(data)\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.main","title":"<code>main</code>","text":"<p>Main implementation of the server.</p>"},{"location":"source/temperatur_server/#temperatur_server.main.api_manager","title":"<code>api_manager</code>","text":""},{"location":"source/temperatur_server/#temperatur_server.main.app","title":"<code>app</code>","text":""},{"location":"source/temperatur_server/#temperatur_server.main.database","title":"<code>database</code>","text":""},{"location":"source/temperatur_server/#temperatur_server.main.host","title":"<code>host</code>","text":""},{"location":"source/temperatur_server/#temperatur_server.main.port","title":"<code>port</code>","text":""},{"location":"source/temperatur_server/#temperatur_server.main.predictor","title":"<code>predictor</code>","text":""},{"location":"source/temperatur_server/#temperatur_server.main.server_state","title":"<code>server_state</code>","text":""},{"location":"source/temperatur_server/#temperatur_server.main.socketio","title":"<code>socketio</code>","text":""},{"location":"source/temperatur_server/#temperatur_server.main.cb_new_input_data","title":"<code>cb_new_input_data(new_data)</code>","text":"<p>Callback for new arrived input Measurements.</p> <p>Parameters:</p> Name Type Description Default <code>new_data</code> <code>List[Measurement]</code> <p>New Measurements.</p> required Source code in <code>temperatur_server/main.py</code> <pre><code>def cb_new_input_data(new_data: List[Measurement]):\n\"\"\"Callback for new arrived input Measurements.\n    Args:\n        new_data (List[Measurement]): New Measurements.\n    \"\"\"\ndatabase.append(new_data)\ntemp_1 = (0, 0.0)\ntemp_2 = (0, 0.0)\n# TODO: accept also messages with one new temp\nfor data in new_data:\nif data[\"name\"] == \"1\":\ntemp_1 = (data[\"ts\"], data[\"value\"])\nelif data[\"name\"] == \"2\":\ntemp_2 = (data[\"ts\"], data[\"value\"])\napi_manager.emit_all(\"new_temp_data\", [temp_1, temp_2])\nresult = predictor.maybe_get_result()\nif result is not None:\napi_manager.emit_all(\"new_prediction\", [result.to_list()])\nif not predictor.is_running() and (\n(time.time_ns() - server_state.last_pushed) * 1e-9 &gt; server_state.predictor_dt\n):\npredictor.run_parallel(\nPredictionInputData(\n*database.getInterpolBetweenTime(\nserver_state.predictor_dt, server_state.start_time\n),\nserver_state.start_time,\nserver_state.core_ref_temp,\n)\n)\nserver_state.last_pushed = time.time_ns()\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.main.index","title":"<code>index()</code>","text":"Source code in <code>temperatur_server/main.py</code> <pre><code>@app.route(\"/\")\ndef index():\nreturn render_template(\"index.html\")\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.main.main","title":"<code>main()</code>","text":"<p>Main function starting the server.</p> Source code in <code>temperatur_server/main.py</code> <pre><code>def main():\n\"\"\"Main function starting the server.\"\"\"\nsocketio.run(app, port=port, host=host, debug=True)\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.main.receive_input","title":"<code>receive_input()</code>","text":"Source code in <code>temperatur_server/main.py</code> <pre><code>@app.route(\"/input\", methods=[\"POST\"])\ndef receive_input():\ndata = request.get_data(as_text=True)\nnew_sensor_data = parse_string(data)\ncb_new_input_data(new_sensor_data)\nreturn \"Measurement Received\"\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.server_state","title":"<code>server_state</code>","text":"<p>Implementation to mange the state of the server</p>"},{"location":"source/temperatur_server/#temperatur_server.server_state.ServerState","title":"<code> ServerState        </code>","text":"<p>Current state of the server.</p> <p>This class holds all configurations which may change during runtime.</p> Source code in <code>temperatur_server/server_state.py</code> <pre><code>class ServerState:\n\"\"\"Current state of the server.\n    This class holds all configurations which may change during runtime.\n    \"\"\"\ndef __init__(self) -&gt; None:\n\"\"\"Initialize with default values.\"\"\"\nself.nano_seconds_before_start = 10 * 60 * 1e9\nself.predictor_dt = 10.0\nself.predictor_oven_functions = 10\nself.predictor_meat_elements = 10\nself.oven_ref_temp = 90.0\nself.core_ref_temp = 64.0\nself.start_time = time.time_ns()\nself.last_pushed = self.start_time\n</code></pre>"},{"location":"source/temperatur_server/#temperatur_server.server_state.ServerState.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize with default values.</p> Source code in <code>temperatur_server/server_state.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize with default values.\"\"\"\nself.nano_seconds_before_start = 10 * 60 * 1e9\nself.predictor_dt = 10.0\nself.predictor_oven_functions = 10\nself.predictor_meat_elements = 10\nself.oven_ref_temp = 90.0\nself.core_ref_temp = 64.0\nself.start_time = time.time_ns()\nself.last_pushed = self.start_time\n</code></pre>"}]}